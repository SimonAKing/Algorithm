/*
大体思路都懂，但看着还是有点晕
现在用 2手动跑一下：

Vis[0][25]=1;

DFS(1,25,1);
Vis[1][25]=1;
Sum=3 : DFS(2,25,0),DFS(1,26,0),DFS(1,24,0)
Vis[1][25]=0;

DFS(0,26,1)
Vis[0][26]=1;
Sum=2 : DFS(1,26,0),DFS(0,27,0), ×DFS(0,25,0),已经标记
Vis[0][26]=0;

DFS(0,24,1)
Vis[0][24]=1;
Sum=2 : DFS(1,24,0),DFS(0,23,0), ×DFS(0,25,0),已经标记
Vis[0][24]=0;

先说明一下，每次DFS之后都要把标记清楚，适用于 N>2的情况

或许推导的时候，你已经发现了点事情。
递归等于分治，不等于动态规划 
解释：
把一件很难的事情 ，分成多个可执行的小事情，大事化小，小事化无，但前提是，不管所有的大事小事，都可以用一种方法去管理它
这就是递归，也就是分治

而DP呢，刚好相反！
可怕的是，DP也可以进行分治的操作，也可兼容方法，但是！
大事化小，小事不可化无！而是 永远持续的小 下去！所以状态转移方程诞生了。 

其实刚搞这题呢，突然陷进误区，忘了递归的特性，一个点可以上 前左右走，那么任意一个点都必须这样走！无论初始方向如何！ 
*/

#include<bits/stdc++.h>
using namespace std;
const int maxn = 50;
bool Vis[maxn][maxn]={0};
int DFS(int x,int y,int N){
	if(N==0){return 1;}
	Vis[x][y]=1;
	int Sum=0;
	if(!Vis[x+1][y]){
		Sum+=DFS(x+1,y,N-1);
	}
	if(!Vis[x][y+1]){
		Sum+=DFS(x,y+1,N-1);
	}
	if(!Vis[x][y-1]){
		Sum+=DFS(x,y-1,N-1);
	}
	Vis[x][y]=0;
	return Sum;
}
int main(){
	int N;
	scanf("%d",&N);
	printf("%d\n",DFS(0,25,N));
	return 0;
} 