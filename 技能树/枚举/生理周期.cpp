//郭炜教授代码 
//解题思路：先找到一个体力高分的日子（第一个for循环）（当然，其他高分也可以） 
//   然后再找到一个情商高分的日子，在此期间有很多天 是可以避开的，因为要保证，结果是三个数的最大公倍数
//   所以 第二个for循环，每次间隔 一个体力高分的周期 去做尝试 ，这样就能确保，结果一定是体力高分倍数
//   直到找到一个即是 体力高分又是情商高分的日子，接下来的尝试 只需试那些 即是体力又是情商高分的日子！
//   所以第二个for循环 的间隔：k+=23*28 情商高分与体力高分的 最小公倍数！直到找到结果！ 
#include <stdio.h>
int main(){
    int p,e,i,d,k,caseNO=0;
    while(scanf("%d %d %d %d",&p,&e,&i,&d) && p!=-1){
        for(k=d+1;(k-p)%23;++k);//第一个循环结果：k一定是在 d 之后，p 之后的 23的最小倍数 与 d之和 
         
        for(;(k-e)%28;k+=23);  // 第二个循环结果：k一定是在 e与p 之后的 28与23 的最小倍数
                        // 注意：每次循环 k+=23，这能确保，在循环的同时，k也是23的倍数，很精髓
                                
        for(;(k-i)%33;k+=23*28);//第三个循环结果：k一定是在 e与p与i 之后的 28与23与33 的最小倍数 
                        // 注意：每次循环 k+=23*28，这样能确保，每次循环都能遵守上面两次循环的规则 
        
        printf("Case %d:the next triple peak occurs in %d days.\n",++caseNO,k-d);
    }
    return 0;
} 
/*自己代码 ，感觉自己 真的弱鸡，真心弱。 
#include <stdio.h>
int main(){
    int a,b,c,d,i,t=0;
    while(scanf("%d %d %d %d",&a,&b,&c,&d) && p!=-1){
        for(i=d+1;i<=21252;++i)
            if((i-a)%23==0 && (i-b)%28==0 && (i-c)%33==0)
                printf("Case %d:the next triple peak occurs in %d days.\n",++t,i-d);
    }
    return 0;
}*/ 

